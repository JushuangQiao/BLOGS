> 简介：初级后端岗位，一面结束，失败。

先做了几个笔试题，面试开始会根据笔试题问一些内容。

#### 1. 一个代码题，要求输出的结果是什么，并解释原因</font>

```python
def f(x, l=[]):
  for i in xrange(x):
      l.append(i**2)
  print l

# 答案见注释
f(2)  # [0, 1]
f(3, [3, 2, 1])  # [3, 2, 1, 0, 1, 4]
f(3)  # [0, 1, 0, 1, 4]
```

简单解释：函数在初始化的时候，会把默认参数放在函数对象的 func_defaults 属性中，例如对于下面的 g 函数，可以看到 func_defaults 属性中会有默认参数的列表。对于 Python 函数中的默认参数，传递的是对象的引用，也就是多次调用的时候，默认参数如果不传，指向的是同一块内存，此时如果在函数内部更改了默认参数的值，会根据参数是否是可变对象有不同的反应。

对于不可变对象，会重新开辟一块内存，可以参考下面的输出可知（当然，对于一些小整数等，Python 是做了优化的，此时依然指向的是同一块内存，如果函数内部 b=2 的话，依然会指向同一块内存）；对于可变对象，则会在原来的内存上进行操作（当然，如果在函数内部进行某些操作，导致内存泄露又是另一个问题了），这会改变 func_defaults 中相应位置的参数的值。

在工作中，除非特殊情况，否则不要用可变对象作为默认参数，不然不知道啥时候会死的很惨的。

```python
In [54]: def g(a, b=2, c=[]):
    ...:     print 'idb:', id(b)
    ...:     print 'idc:', id(c)
    ...:     b='a'
    ...:     print 'idb2:', id(b)
    ...:     c.append(a)
    ...:     print 'idc2:', id(c)
    ...:

In [55]: g.func_defaults
Out[55]: (2, [])

In [56]: g(1)
idb: 140271775913920
idc: 4576730864
idb2: 4555404552
idc2: 4576730864

In [57]: id(g.func_defaults[0])
Out[57]: 140271775913920

In [58]: id(g.func_defaults[1])
Out[58]: 4576730864
```

#### 2. *args 和 **kwargs 是什么，为什么要使用它们？
简单解释：在定义函数或者类方法的时候，如果参数不确定，可以酌情使用他们。
前者可以认为是位置参数，会 pack 成 tuple, 只要传一些顺序的值就好了；
后者则是关键字参数，是一个 dict，需要传递 k = value 的形式。
对于 Python 中的参数、默认参数、*args 和 **kwargs 需要严格按照顺序使用。

（由于 Python 动态语言的灵活性，工作工程中，最好不要用这两种参数定义函数，
很多时候不知道传递的是个啥，需要传递什么，明明就定义了一个接口，还得去看内部的实现才知道怎么用，
当然开源的 Python 包中这种使用还是比较多的，例如著名的 [requests](https://github.com/requests/requests)，如果文档能写的这么完备，当我没说）。

# 未完