# [安全编程指南](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines)


> 这是[文章](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines)的翻译

## 简介
该指南的目的是提供一个简单一致的方法保证 web 应用和 web 服务的安全。指南的内容主要聚焦于 web 应用的安全，但是提到的概念也可以普遍应用于应用程序的安全控制和设计。本文主要聚焦于安全指南，并且会在部分地方提供示例代码。

## 状态
该指南的内容会根据最新的技术进行更新，指南内容确保是正确的，可以放心使用，如果用任何疑问和建议都可以直接邮件联系 mcoates@mozilla.com。

## 布局
该指南主要讨论一些逻辑上的安全以及设计安全应用的方法，而不会去讨论如何防范每种类型的攻击。简而言之，本文是创建安全应用的指南，而不是每种类型的攻击的深度分析。

## 快速开始
以下是几个经常被遗漏但是和绝大部分网站开发相关的要点：<br>
 * 对于所有的 cookie, 设置 HTTPonly 和安全标志；<br>
 * 确保登录授权相关的的页面使用的是 HTTPS；<br>
 * 不要信任任何用户数据（用户输入、headers、cookie 等），使用之前先验证。

## 安全编程指南

### 1. 认证
#### 1.1 需要关注的攻击：

 * 暴力密码破解；
 * 用户枚举；
 * 大规模账号锁定（帐号 DoS)；
 * 离线 hash 攻击（时间权衡）；
 * 丢失密码。

#### 1.2 密码复杂度
网站设计都应该有如下的密码设计策略：

* 密码至少包括 8 个字符；
* 密码至少要包括字符和数字两种类型；
* 需要实行密码黑名单（联系安全部门获取）。

#### 1.3 关键网站
关键网站应该增加如下密码策略：

* 密码需要一个或者多个特殊字符。

#### 1.4 密码轮换
事实证明，密码轮换有点困难，只有在应用内缺少监控或者有一些比较合理的理由时才应该使用，例如密码过短或者缺少密码控制。

* 授权帐户的密码应该 3-4 个月修改一次；
* 普通帐号也建议实行密码轮换；
* 需要对密码修改事件产生应用日志。

#### 1.5 帐号锁定或者登录失败
帐号锁定和登录失败应该根据应用程序进行评估，不管哪种情况，应用程序都应该能够判定是否一遍又一遍的使用同样的密码，或者一直使用不能的密码进行攻击。这两种情况应该返回相同的错误信息，例如

```
The username or password you entered is not valid
```

对于这些异常情况，日志系统将非常关键。这些事件进入了安全系统后，安全系统就可以以此来采取行动。对应用系统来说，也可以采取相应的行动来减缓或停止攻击进程，例如使用图片验证码或者根据 IP 地址进行延迟。只要失败的尝试次数达到限制，就应该使用图片验证码。

#### 1.6 密码重置
进行密码重置的时候将会向用户的邮箱发送一个重置链接，不管用户的用户名和邮箱是否合法，总是会返回如下消息：

```
邮件已经发送到邮箱，更多信息请邮件内查看。如果您没收到邮件，请确认一下注册邮箱是否正确。
```

我们不会提供认可可以让攻击者判断用户名或者密码是否合法的信息，避免攻击者通过网络钓鱼或暴力破解获取到合法帐号。

#### 1.7 修改和验证邮箱功能

发送给邮箱的连接不应该带有验证的 session；

邮箱验证码第一次使用或者 8 小时没使用应该设置过期。

#### 1.8 密码存储
与密码策略不同，存储密码需要遵循以下标准：

* 存储在数据库中的密码需要用 hmac+bcrypt 进行加密。

需要加密的原因如下：

* bcrypt 提供了一种散列机制，可以通过配置来消耗大量的时间，防止多台计算机的暴力破解；
* bcrypt 能够轻松的随时调整，从而增加防护强度，可以用来保护更大的系统；
* hmac 值的密钥存储在文件系统中，而不是存在数据库的密码哈希中。即使数据库由于 SQL 注入而被损坏，密钥由于存在文件系统中，仍然是未知的。由于 bcrypt 和 hmac 的复杂性，显著的增加了暴力破解密码的难度；
* 如果 bcrypt 设计存在缺陷导致密码泄露或者攻击者容易破解，则 hmac 只能作为辅助的防护手段。

这是一个代码示例：https://github.com/fwenzel/django-sha2

时刻记住尽管 bcrypt 是安全的，你仍然需要想一个良好的密码。如果密码是 123，或许通过算法破解会很慢，但是在破解之前别人已经可以猜到了。

#### 1.9 老的密码哈希
* 超过一年的密码哈希值应该从系统中删除；
* 在密码哈希迁移之后，如果用户在三个月内没有登录进行转换，则老的密码哈希值应该被删除。

#### 1.10 迁移
下面的迁移进程使用了不同于上面提到的标准哈希的哈希算法，用来迁移应用。这种方法的好处是能够在用户不重置密码的情况下，立即更新到强的、推荐的哈希算法。

##### 1.10.1 迁移过程：

迁移数据库全部密码哈希实体的过程如下，这是一次性的离线迁移。存储在数据库中的格式是： {algo}${salt}${migration_hash}

>
* {algo} is {sha512+MD5},
* {salt} is a salt unique per-user,
* {migration_hash} is SHA512(salt + existingPasswordHash)

新帐号或者密码改变的帐号用了上面提到的[标准哈希进程](https://github.com/JushuangQiao/blog/blob/master/translation/secure_coding_guidelines.md#18-密码存储)。

##### 1.10.2 新的登录过程

1. 尝试使用新的哈希登录。当然这会涉及到执行旧密码哈希过程，然后加盐，最终执行 sha512；

	>
	Example: Old password hash process is md5
Migration Hash = sha512(perUserSalt + md5(user supplied password))

2. 如果迁移后的哈希认证成功，则用用户提供的密码并根据上面定义的算法计算新哈希，并用新哈希重写迁移后的哈希。
3. 如果认证失败，则用户可能已经用了新哈希，继续用新哈希尝试，还失败的话则提示错误。

### 2. Session 管理

攻击者的关注点：Session 劫持，Session 固定，暴力破解合法 Session IDs。

#### Session ID 长度
Session token 至少需要 128 位。

#### 生成 Session ID
Session token 应该尽可能由服务端处理，或者通过加密的安全随机数生成。

#### 不活跃超时

Session 在授权后，超过一定的时间不活跃应该设置超时，建议时间为 15 分钟。

#### 安全标志位
安全标志位应该在设置 cookie 时产生，这会告诉浏览器不要通过 HTTP 发送 cookie。安全标志位的目的是避免用户点击了一些链接后，cookie 意外泄漏。

[一个示例](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Details#Secure_Flag)

#### HTTP-Only 标志
该标志是为了阻止恶意脚本(XSS)访问用户 Session。

#### 登陆
登陆时应该重新设置 Session，避免通过 XSS 在相关域名或者子域名下的 Session 固定。

#### 登出
登出后 Session 在服务端应该失效，在客户端需要重写或者过期 Session 值。

### 3. 访问控制

