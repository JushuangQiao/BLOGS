# [安全编程指南](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines)


> 这是[文章](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines)的翻译

## 简介
该指南的目的是提供一个简单一致的方法保证 web 应用和 web 服务的安全。指南的内容主要聚焦于 web 应用的安全，但是提到的概念也可以普遍应用于应用程序的安全控制和设计。本文主要聚焦于安全指南，并且会在部分地方提供示例代码。

## 状态
该指南的内容会根据最新的技术进行更新，指南内容确保是正确的，可以放心使用，如果用任何疑问和建议都可以直接邮件联系 mcoates@mozilla.com。

## 布局
该指南主要讨论一些逻辑上的安全以及设计安全应用的方法，而不会去讨论如何防范每种类型的攻击。简而言之，本文是创建安全应用的指南，而不是每种类型的攻击的深度分析。

## 快速开始
以下是几个经常被遗漏但是和绝大部分网站开发相关的要点：<br>
 * 对于所有的 cookie, 设置 HTTPonly 和安全标志；<br>
 * 确保登录授权相关的的页面使用的是 HTTPS；<br>
 * 不要信任任何用户数据（用户输入、headers、cookie 等），使用之前先验证。

## 安全编程指南

### 1. 认证
#### 1.1 需要关注的攻击：

 * 暴力密码破解；
 * 用户枚举；
 * 大规模账号锁定（帐号 DoS)；
 * 离线 hash 攻击（时间权衡）；
 * 丢失密码。

#### 1.2 密码复杂度
网站设计都应该有如下的密码设计策略：

* 密码至少包括 8 个字符；
* 密码至少要包括字符和数字两种类型；
* 需要实行密码黑名单（联系安全部门获取）。

#### 1.3 关键网站
关键网站应该增加如下密码策略：

* 密码需要一个或者多个特殊字符。

#### 1.4 密码轮换
事实证明，密码轮换有点困难，只有在应用内缺少监控或者有一些比较合理的理由时才应该使用，例如密码过短或者缺少密码控制。

* 授权帐户的密码应该 3-4 个月修改一次；
* 普通帐号也建议实行密码轮换；
* 需要对密码修改事件产生应用日志。

#### 1.5 帐号锁定或者登录失败
帐号锁定和登录失败应该根据应用程序进行评估，不管哪种情况，应用程序都应该能够判定是否一遍又一遍的使用同样的密码，或者一直使用不能的密码进行攻击。这两种情况应该返回相同的错误信息，例如

```
The username or password you entered is not valid
```

对于这些异常情况，日志系统将非常关键。这些事件进入了安全系统后，安全系统就可以以此来采取行动。对应用系统来说，也可以采取相应的行动来减缓或停止攻击进程，例如使用图片验证码或者根据 IP 地址进行延迟。只要失败的尝试次数达到限制，就应该使用图片验证码。

#### 1.6 密码重置
进行密码重置的时候将会向用户的邮箱发送一个重置链接，不管用户的用户名和邮箱是否合法，总是会返回如下消息：

```
邮件已经发送到邮箱，更多信息请邮件内查看。如果您没收到邮件，请确认一下注册邮箱是否正确。
```

我们不会提供认可可以让攻击者判断用户名或者密码是否合法的信息，避免攻击者通过网络钓鱼或暴力破解获取到合法帐号。

#### 1.7 修改和验证邮箱功能

发送给邮箱的连接不应该带有验证的 session；

邮箱验证码第一次使用或者 8 小时没使用应该设置过期。

#### 1.8 密码存储
与密码策略不同，存储密码需要遵循以下标准：

* 存储在数据库中的密码需要用 hmac+bcrypt 进行加密。

需要加密的原因如下：

* bcrypt 提供了一种散列机制，可以通过配置来消耗大量的时间，防止多台计算机的暴力破解；
* bcrypt 能够轻松的随时调整，从而增加防护强度，可以用来保护更大的系统；
* hmac 值的密钥存储在文件系统中，而不是存在数据库的密码哈希中。即使数据库由于 SQL 注入而被损坏，密钥由于存在文件系统中，仍然是未知的。由于 bcrypt 和 hmac 的复杂性，显著的增加了暴力破解密码的难度；
* 如果 bcrypt 设计存在缺陷导致密码泄露或者攻击者容易破解，则 hmac 只能作为辅助的防护手段。

这是一个代码示例：https://github.com/fwenzel/django-sha2

时刻记住尽管 bcrypt 是安全的，你仍然需要想一个良好的密码。如果密码是 123，或许通过算法破解会很慢，但是在破解之前别人已经可以猜到了。

#### 1.9 老的密码哈希
* 超过一年的密码哈希值应该从系统中删除；
* 在密码哈希迁移之后，如果用户在三个月内没有登录进行转换，则老的密码哈希值应该被删除。

#### 1.10 迁移
下面的迁移进程使用了不同于上面提到的标准哈希的哈希算法，用来迁移应用。这种方法的好处是能够在用户不重置密码的情况下，立即更新到强的、推荐的哈希算法。

##### 1.10.1 迁移过程：

迁移数据库全部密码哈希实体的过程如下，这是一次性的离线迁移。存储在数据库中的格式是： {algo}${salt}${migration_hash}

>
* {algo} is {sha512+MD5},
* {salt} is a salt unique per-user,
* {migration_hash} is SHA512(salt + existingPasswordHash)

新帐号或者密码改变的帐号用了上面提到的[标准哈希进程](https://github.com/JushuangQiao/blog/blob/master/translation/secure_coding_guidelines.md#18-密码存储)。

##### 1.10.2 新的登录过程

1. 尝试使用新的哈希登录。当然这会涉及到执行旧密码哈希过程，然后加盐，最终执行 sha512；

	>
	Example: Old password hash process is md5
Migration Hash = sha512(perUserSalt + md5(user supplied password))

2. 如果迁移后的哈希认证成功，则用用户提供的密码并根据上面定义的算法计算新哈希，并用新哈希重写迁移后的哈希。
3. 如果认证失败，则用户可能已经用了新哈希，继续用新哈希尝试，还失败的话则提示错误。

### 2. Session 管理

攻击者的关注点：Session 劫持，Session 固定，暴力破解合法 Session IDs。

#### Session ID 长度
Session token 至少需要 128 位。

#### 生成 Session ID
Session token 应该尽可能由服务端处理，或者通过加密的安全随机数生成。

#### 不活跃超时

Session 在授权后，超过一定的时间不活跃应该设置超时，建议时间为 15 分钟。

#### 安全标志位
安全标志位应该在设置 cookie 时产生，这会告诉浏览器不要通过 HTTP 发送 cookie。安全标志位的目的是避免用户点击了一些链接后，cookie 意外泄漏。

[一个示例](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Details#Secure_Flag)，或者看[翻译](https://github.com/JushuangQiao/blog/blob/master/translation/secure_coding_detail.md)

#### HTTP-Only 标志
该标志是为了阻止恶意脚本(XSS)访问用户 Session。

#### 登陆
登陆时应该重新设置 Session，避免通过 XSS 在相关域名或者子域名下的 Session 固定。

#### 登出
登出后 Session 在服务端应该失效，在客户端需要重写或者过期 Session 值。

### 3. 访问控制
关注点：目标站点的网站功能枚举，执行未授权的功能或者修改未授权的数据。

##### 3.1 表达层
只把授权的特征或者功能展示给相应的用户。

不要把链接或者功能展示给未授权的用户，这样可以最少的把访问权限和一些特权信息暴露给未授权用户。

#### 3.2 业务层
执行动作之前先检查权限。

访问之前先验证执行权限，一个用户可能会伪造 GET 或者 POST 请求去执行未授权的功能。

#### 3.3 数据层
对目标数据的访问也要验证权限。

确保授权用户只能在目标数据上进行相应的操作，不要因为用户有了某个数据集的操作，就能在其他数据集上也执行相应的操作。

### 4. 输入验证
关注点：脏数据。

#### 4.1 输入验证的目标
进行输入验证是为了最小化的减少输入造成的脏数据。输入验证不是阻止XSS 和 SQL 注入的主要方法，这些包含在下面章节的输出编码中。

输入验证必须要做到以下几点：

* 适用于任何用户输入的数据；
* 定义可以接受的字符串类型（主要在 U+0020 到 U+007E 之间，虽然可以删除大多数特殊字符，控制字符几乎是不需要的）；
* 限制输入的的字符长度范围，例如 1-25.

这是几个输入验证的例子，对于每个域都定义了可以接受的字符以及接受的字符的长度：

* 用户名：包含字符、数字和特殊字符，3-10 个字符长度；
* 名字：字母、单撇号、下划线，1-30 个字符；
* 简单的 US 压缩码：数字，5 个字符。

注意：这仅仅是一个例子，具体的输入验证需要根据你的具体情况调整。

#### 4.2 javascript 验证 VS 服务端验证
需要注意的是攻击者能够通过禁用 js 或者 Web 代理来绕过 js 验证，所以需要 js 验证的同时，服务端也要进行验证。

#### 4.3 使用积极的方法
攻击者的种类的变化多端的，可以用正则表达式定义好接受的输入，并拒绝任何其他的不符要求的输入。换句话说，我们应该 “接受合法的输入” 而不是 “拒绝不合法的输入”。下面是例子：

> 用户名域接受的合法的输入是如下正则表达式：[0-9a-zA-Z]{3,10}，任何不匹配的输入都要拒绝；
> 拒绝不合法输入的例子是维护一个不合法输入的列表，用户输入的时候进行判断是否在不合法的列表中，但这会带来一个问题，我们很难列举出所有的不合法输入。

#### 4.4 输入验证的鲁棒性
用户输入的任何数据都需要验证，这包括如下：

* 表单数据；
* URL 参数；
* 隐藏域；
* Cookie；
* HTTP 头；
* 任何其他在 HTTP 请求中的数据。

#### 4.5 验证富文本
验证用户输入的富文本非常困难，可以考虑更合适的方法，例如 [HTML Purifier(PHP)](http://htmlpurifier.org),[AntiSamy](http://htmlpurifier.org) 和 [bleach(Python)](https://github.com/mozilla/bleach)。

### 5. 输出编码
输出编码是组织 XSS 和注入攻击的主要方法，输入验证虽然帮助减少了脏数据，但只是一种二次验证。

关注点：XSS 以及各种（SQL/OS/LDAP/XML）注入。

#### 5.1 阻止 XSS
* 当返回 HTML 页面的时候，用户输入的任何数据都需要被编码，以防止恶意数据（如 XSS）的执行。例如 &lt;script&gt; 将会返回 &amplt;script&gt;
* 只对页面中插入用户输入的数据的地方进行具体编码。例如对于 HTML body 中的数据进行 HTML 实体编码就比较合适，然而对于脚本中的用户数据则需要使用 js 进行编码。

[这是一个阻止 XSS 的详细信息。](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)

#### 5.2 阻止 OS 注入
